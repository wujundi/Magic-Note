# 《 剑指 Offer 》 的要点

标签（空格分隔）： 刷题

---

[toc]

***
## 2、面试需要的基础知识

***
### 2.3 数据结构

***
#### （3） 二维数组中的查找
*   不要在循环条件判定的时候使用可能不存在的数组元素。一定要让判定条件充分保证之后使用的值的存在性
*   数组考虑两个情况：1、空的情况 2、循环结束的边界情况
*   不要拘泥为正向顺序遍历，正向逆向哪个好用就用哪个

***
#### （5） 从尾到头打印链表
* 链表和数组这类的基础结构一样，对于 **“空”**、**“尾”** 两个特殊状态的限制与处理是必不可少的。
* **List对象**，作为集合中存储 **有序，可重复**元素的集合，其应用的场景就好像一个 **增强版的数组**。
* 在 **声明集合对象** 的时候，不要忘记 **用 new 进行初始化**。
* 涉及到的知识点：链表、集合类、泛型

***
#### （6） 重建二叉树
* 将一个大问题分解成 一个（多见于顺序操作）或 两个（多见与二叉树）小问题，当发现小问题与大问题在本质上一致时，可以考虑使用递归。
*   遍历一个数组的循环 
```  
 for(int i=0; i<a.length; i++)
```
*   数组的最后一位是 a[a.length-1] ,这个不要马虎
*   注意 **“空”** 的判断与预防
*   对于二叉树，因为子树只会分：左、右。遍历会把空间的逻辑顺序转化成线性的存储顺序，在物理结构与逻辑结构的映射中，**“根节点”，“根节点左侧”，“根节点右侧”** 依据遍历方式的不同，会在线性物理结构上呈现在特定的区域。思维上注意把对树的操作，转化成对于线性存储结构中特定区域的操作。

***
####  （7） 用两个栈实现队列
* **循环的终止条件中涉及的变量尽量不要选择一个每轮都会变的值**。
*    对于数组来说，因为数组的 length 是不变的，那可以用 
```
“i<arr.length”
```
*    但是！但是！**对于栈来说，每次的 push 与 pop 都会改变栈的 size()**，所以，直接使用 stack.size() 作为循环终止的条件会出现错误。

***
### 2.4 算法和数据操作

***
#### （8） 旋转数组的最小数字
* 查找的题目 **一般考虑使用二分查找**，直接遍历的话，毕竟还是 low 了点

***
#### （9） 斐波那契数列
* 递归代码固然好用，但要控制总次数：对于树来说，因为递归次数与树的层数正相关，所以一般不会出现问题；对于数列来说，动辄 10、20 的长度，很可能使得递归实现不堪重负，出现 "StackOverflowError"

***
#### （10） 二进制中 1 的个数
*   要得到二进制中数字 “1” 的个数，不一定要得到二进制数，而可以直接用位运算来处理这个整数
*   位运算的操作分为两种：【与、或、非、抑或】还有【左移、右移】，其中 "移动的操作"是左右推动数字串；而"逻辑操作"，更类似于一种数字串特殊位置的匹配判别。
*  **n & (n-1) 得到的结果相当于是把整数的二进制表示中的最右边一个 1 变成 0** .
*   Integer.toBinaryString(n);可以输出对应的n的二进制表示字符串，但是更多的时候，我们是通过位运算，间接的获得关于目标数值的 二进制表示的 相关信息。

***
## 3、高质量的代码

考虑问题要全面：
功能测试：正常的输入能否实现功能，输入的种类，输入的极限需求
边界测试: 循环结束的条件，递归终止的边界值
负面测试: 对错误的输入的鲁棒，错误的反馈方式

***
### 3.3 代码的完整性

***
#### （11）数值的整数次方
**注意考虑数学公式上参数的全部定义域**。

***
#### （12）打印 1 到最大的 n 位数
关于 n 位 整数并且没有限定 n 的取值范围的题目，或者是 “任意大小的数”，要考虑 **用字符数组 char[] 来表示数字**。

***
#### （13）在 O(1) 时间内，删除链表节点
一般想法：删除一个 由只有后继信息的节点组成的 链表，需要从头节点逐个扫描，才能找到目标节点；
在一种特殊情况下（**当已经能够给出被删除的目标节点的引用时**，给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点）：我们可以 **基于目标节点的引用，将目标点下一个节点的值复制到目标点（使得下一个点作为“替罪羊”），然后删除目标点下一个点**

****
#### （14）调整数组顺序使技术位于偶数前面
代码的可扩展性是需要考虑的因素，如果在一种操作的基础上需要额外的要求，应该想到，不只可以在源代码的基础上添加判断的额外代码。也可以 **将额外的要求单独写成一个方法**，使得在 **原逻辑代码能够以“调用方法”的方式引入额外要求**，从而实现代码的 **解耦**，方便维护与更改“额外要求”

***
### 3.4代码的鲁棒性
进行 “防御性编程”：预见什么地方会出现问题，并为这些问题指定处理预案。
> 防御性编程常用的手段，是在 **函数入口处做出防御**，并且很有可能使用 if......else if......else if......else

***
#### （15）链表中倒数第 K 个结点
用 **两个指针遍历链表**，其中一个为“遍历指针”，用于遍历链表时，另一个可以 **以“遍历指针”为参考，做些其他的事情** 。
可以在遍历的同时，**到达相对于【尾部】的特定位置**。

***
#### （16）反转链表
在编写代码的时候，提前想一想特殊的测试用例，以保证代码的鲁棒性

***
#### （17）合并两个排序的链表
能够循环执行的代码，也可以尝试用递归来实现，反之亦然。
虽然两种方法都可以实现迭代的逻辑，但是，从代码实现的简单程度上来说，可能会有所差别。
**有关对象的引用，时刻注意【空指针问题】**。

***
#### （18）树的子结构
* 当递归需要在首次进行防御的时候，可以把入口函数与递归函数**解耦**。 **防御代码写在入口函数中，递归代码专心执行递归**。
* 在执行 **遍历，递归，循环**，等操作时，**每一步**都要问自己，这个时候，**会不会出现 null**，如果出现，是怎么个情况，要怎么办？**

***
## 4、解决面试题的思路


***
### 4.2 画图让抽象问题形象化
借助图形来发现复杂问题的规律

***
#### （19）二叉树的镜像

***
#### （20）顺时针打印矩阵


***
### 4.3 举例让抽象问题具体化
借助一两个具体的例子来模拟操作的过程，从而发现隐藏的规律

***
#### （21）包含 min 函数的栈
* 写赋值语句之间的三问：
```
现在这个东西是不是基本类型
这样赋值之后，它们是不是指向了同一个对象
我的本意呢？是要两台相同的电视？还是给同一个电视多配一个遥控器？
```
* 移动对象指针时候，该指针中所有的参数值都会被重写
```
    //top.next = new Node(val);
    //top.pre = top;
    //top = top.next;
    //原来的想法：先移动top的next和pre指针，当指针指好之后，再移动top的位置。
    //实际的情况却是：移动top指针的时候，旧指针的一切信息都会被覆盖掉
```

***
#### （22）栈的压入、弹出序列
* 与斐波那契数列相关的问题相对比，斐波那契相关问题是把问题转化到数学归纳法上，而并非要用程序模拟真实操作；但是本题的思路却是要 **用程序 “模拟” 栈的 push 与 pop 的操作** 来判断结果。
* 猜想一下相关的原因：斐波那契系列问题要计算可能性的数量，实际发生的情况太多，且问题实质是具有归纳性的（此类问题，多考虑动态规划）；本题的“栈”，本就是个程序上的概念，便于模拟，并且分析本题时会发现，核心问题并不存在数学上的归纳关系，反而呈现出易于模拟的特点。

***
#### （23）从上往下打印二叉树
* 在“防空”工作中，有时意味着返回一个什么都没有的数据，虽然没有任何数据，但是**切记保证其数据类型符合函数头定义**
* 返回一个 null ，在逻辑上是说的通的，但是，函数头写明返回值是一个 ArrayList类型，**空的 ArrayList 也是一个 ArrayList，你返回个 null 是几个意思**？

***
#### （24）二叉搜索树的后续遍历序列
* 递归的时候，对于每一级传递的参数要十分谨慎；细小的偏差，在递归的时候，会造成巨大的偏差

***
#### （25）二叉树中和为某一值的路径

* 做题目时先以思路为主，以最暴力的方式，实现思路的具象化，然后再修改性能

* 有关递归，要清醒的认识到 **上一级的调用自己的那一行代码 = 下一级的整个函数体**，

* 换句话说，**本级的函数完整的执行之后，回到上一级，只换来上一级一行代码的扫过**

*   对于“递归”中“返回上一级”的理解要清晰：本级代码执行完毕之后，不一定非要产生多大影响，也可能全然没有影响，**只是相当于 “ 详细的执行了上一级的那一行代码 ”**

* 解释下新技能
```
result.add(new ArrayList<Integer>(valList));
//1、集合类在初始化的时候可以直接复制另一个集合实体的数据
//2、集合本身不是基本类型，也是按照引用传递，所以result.add(valList);之后，也还要提防 valList被篡改

```

***
### 4.4 分解让复杂问题简单化
所谓“各个击破”

***
#### （26）复杂链表的复制
* 如果想要更为方便的拿到链表中节点的信息，可以采用本题推荐的这种方式：**直接在目标节点之后插入一个新增的节点，以后再把它拿出来**
* 对于链表的题目中，一定要注意在使用 next 时 **确保对象的存在性**，否则 a.next 会报出 **空指针异常**

***
#### （27）二叉搜索树与双向链表


***
#### （28）字符串的排列
*   几个函数都要使用的变量，除了放置在类中作为成员变量，也可以作为参数，在方法之间传递

*   【全排列】
```
public void helper(ArrayList<String> a, int index, char[] s){
	    
		if(index == s.length-1){//如果递归到了最后一位，那就生成一个结果，加入结果集
			a.add(new String(s));
		}
		
		/*
		 * 全排列
		 * a、把字符串非为两部分，首位，和剩余部分
		 * 1、每种情况下先运算剩余部分的全排列
		 * 2、然后使首位逐一与剩余位置交换，再进行1步骤
		 */
	    for(int i=index; i<s.length; i++){
	        if(i==index||s[index]!=s[i]){//i==index的时候，两个位置的值肯定是相等的；一旦i与index错开，并且两个位置的元素还一致，此时交换就会产生重复的结果
	            swap(s,index,i);//与其余位置元素交换
	            helper(a,index+1,s);//对其余位置进行全排列
	            swap(s,index,i);//恢复到交换之前的样子
	        }
	    }
	}
```
* 发现在大问题的步骤中，有相同的小操作，应该往递归上联想,小操作就是每一步的操作，而大小操作的关联，就是串起递归的关键
* 若题目是按照要求摆放若干数字，可以先求出这些数字的所有排列，以逐一判断是否存在满足题设条件的情况。

***
### 4.5 本章小结

遇到难题三板斧：画图，举例子，分解

1、链表，二叉树等抽象数据结构，画图之后更容易找到规律，按图寻找规律，会使得分析思路更加清晰

2、遇到“平面性质”不强的题目，可能不容易从图中发现规律，甚至不容易画出图来，此时可以选择一些基本的算例，带入题设中，找出其中隐含的规律。

3、真正无法简化的问题，一般是不会出现在面试题目中的，在画图或者举例中，往往会发现某些“相同的操作”，这是分解问题的信号，找出“相同的操作”与每一轮操作之间的关联，往往能够构造出递归的全貌。

4、其次，遇到复杂问题，为保证主程序思路清晰，考虑将部分操作移入“辅助函数”也是很好的选择。


***
## 5、优化时间和空间效率

***
### 5.2 时间效率

*** 
#### （29）数组中出现次数超过一半的数字
* 数组这类题目，有条件的，应该自己写个main，测试一下

* 对于数组的防空，要考虑：
1、引用为null；
2、数组长度<=0

***
#### （30）最小的 k 个数
* 海量数据下，这道题的思路应该是维护一个 **规模为 k 的最大堆**，然后过数据就可以了。 

***
#### （31）连续子数组的最大和
* **全正数，正负数混合，全负数**，这三种情况很考验代码的鲁棒性，要多家思考验证。

***
#### （32）从 1 到 n 证书中 1 出现的次数

***
#### （33）把数组拍成最小的数
*  涉及到排序的题目很多，有些直接比较大小，有些却需要更为复杂的判断方法。
*  注重 **compare 函数的广义化**，会使得很多问题有更为简单的可能

***
### 5.3 时间效率和空间效率的平衡

***
#### （34）丑数
* 操作数组时，一定要明确变量表示的是index，还是该位置上的值，必要时，采用变量名采用前缀区分：i_ ,v_
* 在做需要 **基于已有数据生成新数据** 的题目时，最好是由已知数据向未知方向检查；如果采用，由 **未知数据**，经处理后，**在已知数据中查找**，就不能避免数据量大时，**遍历已有数据** 带来的 **时间耗损** 了

***
#### （35）第一次只出现一次的字符
*   题目描述的问题，实际是 “全部由字母组成”
*   涉及到字符判断的问题，可以按照其ASCII码的规律，使用数组建立简易的哈希。‘A-Z’65-90，‘a-z’97-122
*   java 中 **char与ASCII码** 的转换靠 **强制类型转换**：
```
int asc = (int)'A' ; 
char cha = (char)65 ;
```

***
#### （36）数组中的逆序对
* 熟练准确地掌握常见算法的思路与代码实现，在复杂的题目中，发现类似的地方能够有所迁移是最好的
* 逆序数，使用归并的思维

***
#### （37）两个链表的第一个公共结点
* 对于处于特殊状态的数据结构，要尽可能的洞察它的每一个特性，针对这些特性做文章往往是破题之法

***
## 6、面试中的各项能力


***
### 6.1 面试官谈能力
* 礼貌平和、不卑不亢的交流
* 逻辑清晰、详略得当的介绍自己及项目经历
* 谈论题目时，能够发现细节并向面试官询问
* 对自己的项目深入了解，对面试题目快速寻找解决方法
* 给出无法回答的问题，并给出答案，观察沟通能力与求知欲
* 学习能力靠没有接触过的问题来考核
* 清晰有条理的表达自己
* 在得到信息不足的时候主动发问，所有用于明确问题的发问都是被期待的
* 得到暗示后，迅速纠正错误
* 对于抛出的新概念，不清楚就问，体现学习能力

***
### 6.3 知识迁移能力
* 有可能先给一个小问题，在逐步扩大到大规模问题
* 有想法先说，表明“思维活跃”，然后再改进

***
####（38）数组在排序数组中出现的次数
* **有序数组** 最好就不要遍历啦，**二分查找！**二分查找！

***
#### （39-1）二叉树的深度
* 深度优先遍历时，跟随的深度计数变量的方法，需要总结
* 深度优先和广度优先算法虽然是图的算法，但是经常作用到树中，应该掌握
* **二叉树** 想到使用 **递归** 算法才是上策

***
#### （39-2）判断平衡二叉树
* 遇到判定数据结构是否属于特定结构的题目，除非有完全的把握，否则一般应该按照定义判别，而不要转移判定条件（复杂数据结构下，转移的判定条件与定义很容易出现不等价的情况）

***
#### （40）数组中只出现一次的数字

***
#### （41-1）和为 S 的两个数字

***
#### （41-2）和为 S 的连续正数序列
*   该题默认【单个数字】不属于【连续序列】

***
#### （42-1）翻转单词顺序
* 错在没有考虑纯空格的情况
* 分割解决问题的想法要常有，这样才能想到递归的用途
* 通用常识：翻转数组元素，双指针，首尾互换，指针相向运动

***
#### （42-2）左旋转字符串
* 再明确一下**“防空”** 的注意点：
**1、应用对象本身为空**；
**2、对象（数组，字符串）长度为 0**；

***
### 6.4 抽象建模能力

***
#### （44）扑克牌顺子
* for循环的第二个表达式如果需要多重判断，在考虑双目逻辑运算符短路的特性的情况下，应该将 **数组越界的条件写在最前面**。
* 程序的递归和遍历的 **边界**，要和选择的结果集合相匹配，**ArrayList** 可以根据 **元素的数目** 取边界，但是，**数组** 的边界一定会是 **数组的声明长度（ 到 arr[arr.length-1] ）**。

***
#### （45）圆圈中最后剩下的数字
* **选用合适的数据结构** 对题目进行抽象，将起到事半功倍的效果。
* 熟悉数据 **结构的变体**，有可能有 **不熟悉的性质**，**强烈建议 debug** ，跟踪一下
* 复习一下链表中删除当前指针节点的过程

***
### 6.5 发散思维能力
8 故意限制应聘者的常规思路，观察应聘者有没有积极的心态与探索的激情

***
#### （46）求 1+2+···+N（限制）
* 位运算：右移一位相当于除2，左移一位相当于乘2

***
#### （47）不用加减乘除做加法


***
## 7 两个面试案例