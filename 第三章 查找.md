# 第三章 查找
标签（空格分隔）： Algorithms学习笔记

---

[toc]

---

# 3.1 符号表
## 先导：符号表

>**符号表：**是一种存储键值对的数据结构，算法不能离开API单独存在。如同第二章中“排序算法的程序结构一样”，在第三章中，依然需要一个一份API来把各种不同的排序算法和实际的使用联系起来。在查找的时候，程序所直接使用的是符号表。各个算法的区别体现在，符号表的具体方法用不同的算法实现之后，性能的不同。

* 简单符号表的API
```
public class ST<Key,Value>
    ST()                       构造函数
void put(Key key,Value val)     将键值对存入符号表
Value get(Key key)              获取key对应的值
void delete(Key key)            删除key对应的键值对
boolean contains(Key key)       判断符号表中是否有对应的值
boolean isEmpty()               判断符号表是否为空
int size()                      获得符号表键值对数量
Iterable<Key> keys()            表中所有键的集合
```
* 有序符号表的API
```
public class ST<Key extends Comparable<key>,Value>
    ST()                        构造函数
void put(Key key,Value val)     将键值对存入符号表
Value get(Key key)              获取key对应的值
void delete(Key key)            删除key对应的键值对
boolean contains(Key key)       判断符号表中是否有对应的值
boolean isEmpty()               判断符号表是否为空
int size()                      获得符号表键值对数量
Key min()                       最小的键
Key max()                       最大的键
Key floor(Key key)              小于等于key的最大键
Key ceiling(Key key)            大于等于key的最小键
int rank(Key key)               小于key的键的数量，对于有序的键值对，其实就是该键的位置
Key select(int k)               排名为k的键
void deleteMin()                删除最小的键
void deleteMax()                删除最大的键
int size(Key lo, Key hi)        [lo..hi]之间键值对数量
Iterable<Key> keys(Key lo, Key hi)  [lo..hi]之间的所有键
Iterable<Key> keys()            表中所有键
```

## 顺序查找
下面给出一个基于链表的顺序搜索的例子
```
public class SequentialSearchST<Key, Value> {
    private int n;           // 键值对数
    private Node first;      // 链表首结点

    // 链表节点的定义
    private class Node {
        private Key key;
        private Value val;
        private Node next;

        public Node(Key key, Value val, Node next)  {
            this.key  = key;
            this.val  = val;
            this.next = next;
        }
    }

    // 构造方法
    public SequentialSearchST() {}
    
    public int size() {
        return n;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public Value get(Key key) {
        if (key == null) throw new NullPointerException("argument to get() is null"); 
        for (Node x = first; x != null; x = x.next) { // x为空时，意味着链表遍历结束，故终止循环
            if (key.equals(x.key))
                return x.val;
        }
        return null;
    }
    
    public boolean contains(Key key) {
        if (key == null) throw new NullPointerException("argument to contains() is null");
        return get(key) != null;
    }

    //写入新数据（覆盖或新增）
    public void put(Key key, Value val) {
        //首先对于“空键”与“空值”做出反应
        if (key == null) throw new NullPointerException("first argument to put() is null");
        if (val == null) {
            delete(key);
            return;
        }
        //遍历链表，查找目标值
        for (Node x = first; x != null; x = x.next) {
            if (key.equals(x.key)) { //找到对应的键之后，把值写进去，并且跳出方法
                x.val = val;
                return; // 找到目标并且写入后，会跳出方法，不执行最后两句代码
            }
        }
        first = new Node(key, val, first);//如果没有找到目标值，就在链表起始处新建一个节点
        n++; // 总数加1
    }
```
* 删除方法
```
    public void delete(Key key) {
        if (key == null) throw new NullPointerException("argument to delete() is null"); 
        first = delete(first, key);
    }

    private Node delete(Node x, Key key) {
        if (x == null) return null;
        if (key.equals(x.key)) {
            n--; // 总数减1
            return x.next; // 返回该结点删除后，顶替上来的结点
        }
        x.next = delete(x.next, key); // 如果当前结点的值并没有与目标值相等，那么递归到下一个点去判断
        return x;
    }
```
这里体现出递归的优势，在把判断不断的推向下一个节点的过程中，既然保留了对每一个节点next的修改操作。递归可以看作由“寻找”+“反溯”两个阶段构成：**寻找**负责不断地推进操作走向下一个位置，**反溯**负责在寻找的路径上，执行一些善后的工作。
```
    //Returns all keys in the symbol table as an {@code Iterable}.
    public Iterable<Key> keys()  {
        Queue<Key> queue = new Queue<Key>();
        for (Node x = first; x != null; x = x.next)
            queue.enqueue(x.key);
        return queue;
    }

    public static void main(String[] args) {
        SequentialSearchST<String, Integer> st = new SequentialSearchST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }
        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
    }
}
```

## 二分查找
信奉绝对的“中间点”，依靠有序数组，每次都寻找中间点，取“左半个”或者“右半个”
```
public class BinarySearchST<Key extends Comparable<Key>, Value> {
    private Key[] keys; //键数组
    private Value[] vals; //值数组
    private int n = 0; //符号表长度

    //二分查找也是包前包后的，只要前后端没发生交叉，都可以继续下去
    public int rank(Key key) {
        int lo = 0, hi = n-1; 
        while (lo <= hi) { //不断执行循环，缩小搜索范围，直到lo与hi重合
            int mid = lo + (hi - lo) / 2; //计算出绝对中点
            int cmp = key.compareTo(keys[mid]); //判别参数
            if      (cmp < 0) hi = mid - 1; 
            else if (cmp > 0) lo = mid + 1; 
            else return mid; 
        } 
        return lo;
    } 
    
    // 思考 while 循环结束的条件，结束是由"hi<lo"触发的，在循环结束之时，有两种情况：
    // 1、正好找到了等于目标值的 mid，直接 return，跳过后续代码，直接使函数结束
    // 2、没有找到目标值，根据此程序需要返回某个值

}
```

# 3.2 二叉查找树
采用相对分割点的树。
将二分查找的效率和链表的灵活结合起来
```
public class BST<Key extends Comparable<Key>, Value> {
    private Node root;             // root of BST

    private class Node {
        private Key key;           // sorted by key
        private Value val;         // associated data
        private Node left, right;  // left and right subtrees
        private int size;          // number of nodes in subtree

        public Node(Key key, Value val, int size) {
            this.key = key;
            this.val = val;
            this.size = size;
        }
    }

    // Initializes an empty symbol table.
    public BST() { }

    public boolean isEmpty() {return size() == 0;}

    public int size() {return size(root);}

    // return number of key-value pairs in BST rooted at x
    private int size(Node x) {
        if (x == null) return 0;
        else return x.size;
    }

    // Does this symbol table contain the given key?
    public boolean contains(Key key) {
        if (key == null) throw new NullPointerException("argument to contains() is null");
        return get(key) != null;
    }

    // Returns the value associated with the given key.
    public Value get(Key key) { // 调用入口
        return get(root, key);
    }

    private Value get(Node x, Key key) { // 迭代方法
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if      (cmp < 0) return get(x.left, key);
        else if (cmp > 0) return get(x.right, key);
        else              return x.val;
    }

    // 新增、覆盖数据
    public void put(Key key, Value val) { //方法入口
        if (key == null) throw new NullPointerException("first argument to put() is null");
        if (val == null) {
            delete(key);
            return;
        }
        root = put(root, key, val);
        assert check();
    }

    private Node put(Node x, Key key, Value val) { //迭代方法
        if (x == null) return new Node(key, val, 1);
        int cmp = key.compareTo(x.key);
        if      (cmp < 0) x.left  = put(x.left,  key, val);
        else if (cmp > 0) x.right = put(x.right, key, val);
        else              x.val   = val; //递归寻找合适的位置
        // 对于沿途个节点size的修改放在递归代码之后，作用于递归反溯的时候
        x.size = 1 + size(x.left) + size(x.right); /
        return x;
    }


    // Removes the smallest key and associated value from the symbol table.
    public void deleteMin() {
        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow");
        root = deleteMin(root);
        assert check();
    }

    private Node deleteMin(Node x) {
        if (x.left == null) return x.right;
        /*当x的左子树为空的时候，就说明这个x就是要删除的最小值了。
        *最小值可以删，但是子树数据不能丢，所以这里把它的右子树接在它的位置上。
        *把x挤掉，就相当于把它删除了*/
        x.left = deleteMin(x.left);
        x.size = size(x.left) + size(x.right) + 1;
        return x;
    }

    // Removes the largest key and associated value from the symbol table.
    public void deleteMax() {
        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow");
        root = deleteMax(root);
        assert check();
    }

    private Node deleteMax(Node x) {
        if (x.right == null) return x.left;
        x.right = deleteMax(x.right);
        x.size = size(x.left) + size(x.right) + 1;
        return x;
    }

    // Removes the specified key and its associated value from this symbol table     
    public void delete(Key key) {
        if (key == null) throw new NullPointerException("argument to delete() is null");
        root = delete(root, key);
        assert check();
    }

    private Node delete(Node x, Key key) {
        if (x == null) return null;

        int cmp = key.compareTo(x.key);
        if      (cmp < 0) x.left  = delete(x.left,  key);
        else if (cmp > 0) x.right = delete(x.right, key);
        else { //这里是在cmp==0，也就是找到删除目标的情况下
            if (x.right == null) return x.left;
            if (x.left  == null) return x.right;
            //当两个子树都不为空的情况下
            Node t = x;
            x = min(t.right); //将x的右子树中最小的结点作为x的继任者
            x.right = deleteMin(t.right); //继任者的右子树是去掉它之后的右子树
            x.left = t.left; //继任者的左子树就是原来的左子树
        } 
        x.size = size(x.left) + size(x.right) + 1;
        return x;
    } 


    // Returns the smallest key in the symbol table.
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("called min() with empty symbol table");
        return min(root).key;
    } 

    private Node min(Node x) { 
        if (x.left == null) return x; 
        else                return min(x.left); 
    } 

    // Returns the largest key in the symbol table.
    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("called max() with empty symbol table");
        return max(root).key;
    } 

    private Node max(Node x) {
        if (x.right == null) return x; 
        else                 return max(x.right); 
    } 

    // Returns the largest key in the symbol table less than or equal to {@code key}.
    public Key floor(Key key) {
        if (key == null) throw new NullPointerException("argument to floor() is null");
        if (isEmpty()) throw new NoSuchElementException("called floor() with empty symbol table");
        Node x = floor(root, key);
        if (x == null) return null;
        else return x.key;
    } 

    private Node floor(Node x, Key key) {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp == 0) return x; //分割点就是目标值的情况
        if (cmp <  0) return floor(x.left, key); //分割点比目标值大的情况，直接选择左子树递归
        Node t = floor(x.right, key); //对于向右的移动，留有回退的余地
        if (t != null) return t;
        else return x; 
    } 

    //Returns the smallest key in the symbol table greater than or equal to {@code key}.
    public Key ceiling(Key key) {
        if (key == null) throw new NullPointerException("argument to ceiling() is null");
        if (isEmpty()) throw new NoSuchElementException("called ceiling() with empty symbol table");
        Node x = ceiling(root, key);
        if (x == null) return null;
        else return x.key;
    }

    private Node ceiling(Node x, Key key) { //与floor的套路基本是一致的，只要添加省略掉的if语句，再调换一下代码顺序，就一模一样了
        if (x == null) return null; 
        int cmp = key.compareTo(x.key);
        if (cmp == 0) return x; //分割点就是目标值的情况
        if (cmp < 0) { //目标值小于分割点的情况
            Node t = ceiling(x.left, key); 
            if (t != null) return t;
            else return x; 
        } 
        return ceiling(x.right, key); 
    } 

    // Return the kth smallest key in the symbol table.
    public Key select(int k) {
        if (k < 0 || k >= size()) throw new IllegalArgumentException();
        Node x = select(root, k);
        return x.key;
    }

    // Return key of rank k. 
    private Node select(Node x, int k) {
        if (x == null) return null; 
        int t = size(x.left); 
        if      (t > k) return select(x.left,  k); 
        else if (t < k) return select(x.right, k-t-1); 
        else            return x; 
    } 

    // Return the number of keys in the symbol table strictly less than {@code key}.
    public int rank(Key key) {
        if (key == null) throw new NullPointerException("argument to rank() is null");
        return rank(key, root);//调用递归方法
    } 

    // Number of keys in the subtree less than key.
    private int rank(Key key, Node x) {
        if (x == null) return 0; 
        int cmp = key.compareTo(x.key); 
        if      (cmp < 0) return rank(key, x.left); 
        else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right); 
        else              return size(x.left); 
    } 

    // Returns all keys in the symbol table as an {@code Iterable}.
    public Iterable<Key> keys() {
        return keys(min(), max());
    }

    // Returns all keys in the symbol table in the given range, as an {@code Iterable}.
    public Iterable<Key> keys(Key lo, Key hi) {
        if (lo == null) throw new NullPointerException("first argument to keys() is null");
        if (hi == null) throw new NullPointerException("second argument to keys() is null");

        Queue<Key> queue = new Queue<Key>();
        keys(root, queue, lo, hi);
        return queue;
    } 

    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) { 
        if (x == null) return; 
        int cmplo = lo.compareTo(x.key); 
        int cmphi = hi.compareTo(x.key); 
        if (cmplo < 0) keys(x.left, queue, lo, hi); 
        if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key); 
        if (cmphi > 0) keys(x.right, queue, lo, hi); 
    } 

    // Returns the number of keys in the symbol table in the given range.
    public int size(Key lo, Key hi) {
        if (lo == null) throw new NullPointerException("first argument to size() is null");
        if (hi == null) throw new NullPointerException("second argument to size() is null");

        if (lo.compareTo(hi) > 0) return 0;
        if (contains(hi)) return rank(hi) - rank(lo) + 1;
        else              return rank(hi) - rank(lo);
    }

    // Returns the height of the BST (for debugging).
    public int height() {
        return height(root);
    }
    private int height(Node x) {
        if (x == null) return -1;
        return 1 + Math.max(height(x.left), height(x.right));
    }

    // Returns the keys in the BST in level order (for debugging).
    public Iterable<Key> levelOrder() {
        Queue<Key> keys = new Queue<Key>();
        Queue<Node> queue = new Queue<Node>();
        queue.enqueue(root);
        while (!queue.isEmpty()) {
            Node x = queue.dequeue();
            if (x == null) continue;
            keys.enqueue(x.key);
            queue.enqueue(x.left);
            queue.enqueue(x.right);
        }
        return keys;
    }

  /*************************************************************************
    *  Check integrity of BST data structure.//这部分代码我没看
    ***************************************************************************/
    private boolean check() {
        if (!isBST())            StdOut.println("Not in symmetric order");
        if (!isSizeConsistent()) StdOut.println("Subtree counts not consistent");
        if (!isRankConsistent()) StdOut.println("Ranks not consistent");
        return isBST() && isSizeConsistent() && isRankConsistent();
    }

    // does this binary tree satisfy symmetric order?
    private boolean isBST() {
        return isBST(root, null, null);
    }

    // is the tree rooted at x a BST with all keys strictly between min and max
    private boolean isBST(Node x, Key min, Key max) {
        if (x == null) return true;
        if (min != null && x.key.compareTo(min) <= 0) return false;
        if (max != null && x.key.compareTo(max) >= 0) return false;
        return isBST(x.left, min, x.key) && isBST(x.right, x.key, max);
    } 

    // are the size fields correct?
    private boolean isSizeConsistent() { return isSizeConsistent(root); }
    private boolean isSizeConsistent(Node x) {
        if (x == null) return true;
        if (x.size != size(x.left) + size(x.right) + 1) return false;
        return isSizeConsistent(x.left) && isSizeConsistent(x.right);
    } 

    // check that ranks are consistent
    private boolean isRankConsistent() {
        for (int i = 0; i < size(); i++)
            if (i != rank(select(i))) return false;
        for (Key key : keys())
            if (key.compareTo(select(rank(key))) != 0) return false;
        return true;
    }


    // Unit tests the {@code BST} data type.
    public static void main(String[] args) { 
        BST<String, Integer> st = new BST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        for (String s : st.levelOrder())
            StdOut.println(s + " " + st.get(s));

        StdOut.println();

        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
    }
}

```
二叉查找树在查找的性能上来说已经挺好的了，但是有一个不得不说的问题：二叉查找树在最坏情况下（插入的元素是有序的），会使得树的深度急剧增加，从而增加查找判别次数。

# 3.3 平衡查找树
二叉树在最坏情况下的劣势，在一定程度上是由于其过分严格的结点限制。平衡查找树适当的扩充了节点的容量，使得一个节点可以容纳两个键值对，从而最多形成三个子树。依靠局部的变形，来消化新加入的节点对于树的影响，从而保证树的深度不会过分的增加。
## 先导：2-3查找树
这一部分先导，书中有图，文字不好表述
## 红黑树

```
public class RedBlackBST<Key extends Comparable<Key>, Value> {

    private static final boolean RED   = true;
    private static final boolean BLACK = false;

    private Node root;     // root of the BST

    // BST helper node data type
    private class Node {
        private Key key;           // key
        private Value val;         // associated data
        private Node left, right;  // links to left and right subtrees
        private boolean color;     // color of parent link
        private int size;          // subtree count

        public Node(Key key, Value val, boolean color, int size) {
            this.key = key;
            this.val = val;
            this.color = color;
            this.size = size;
        }
    }

    //构造方法
    public RedBlackBST() {}

   /***************************************************************************
    *  Node helper methods.
    ***************************************************************************/
    
    // is node x red; false if x is null ?
    private boolean isRed(Node x) {
        if (x == null) return false;
        return x.color == RED;
    }

    // number of node in subtree rooted at x; 0 if x is null
    private int size(Node x) {
        if (x == null) return 0;
        return x.size;
    } 

    public int size() {return size(root);}

    public boolean isEmpty() {return root == null;}

   /***************************************************************************
    *  Standard BST search.
    ***************************************************************************/

    //Returns the value associated with the given key.
    public Value get(Key key) {
        if (key == null) throw new NullPointerException("argument to get() is null");
        return get(root, key);
    }

    // value associated with the given key in subtree rooted at x; null if no such key
    private Value get(Node x, Key key) {
        while (x != null) {
            int cmp = key.compareTo(x.key);
            if      (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else              return x.val;
        }
        return null;
    }

    //Does this symbol table contain the given key?
    public boolean contains(Key key) {
        return get(key) != null;
    }

   /***************************************************************************
    *  Red-black tree insertion.
    ***************************************************************************/

    // 插入、覆盖节点
    public void put(Key key, Value val) {
        if (key == null) throw new NullPointerException("first argument to put() is null");
        if (val == null) {
            delete(key);
            return;
        }

        root = put(root, key, val);
        root.color = BLACK;
        // assert check();
    }

    // insert the key-value pair in the subtree rooted at h
    private Node put(Node h, Key key, Value val) { 
        //若没有已有的键与目标匹配，就新建一个树结点
        if (h == null) return new Node(key, val, RED, 1);

        int cmp = key.compareTo(h.key);
        if      (cmp < 0) h.left  = put(h.left,  key, val); 
        else if (cmp > 0) h.right = put(h.right, key, val); 
        else              h.val   = val; //如果找到现有的键与目标匹配，就覆盖匹配的键值对

        // fix-up any right-leaning links
        if (isRed(h.right) && !isRed(h.left))      h = rotateLeft(h);//右红左不红，向左翻转
        if (isRed(h.left)  &&  isRed(h.left.left)) h = rotateRight(h);//左红左左红，向右翻转
        if (isRed(h.left)  &&  isRed(h.right))     flipColors(h);//两边都红，都变黑
        h.size = size(h.left) + size(h.right) + 1;

        return h;
    }
    
    // make a left-leaning link lean to the right
    private Node rotateRight(Node h) { //见图3.3.17
        // assert (h != null) && isRed(h.left);
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = x.right.color;
        x.right.color = RED;
        x.size = h.size;
        h.size = size(h.left) + size(h.right) + 1;
        return x;
    }

    // make a right-leaning link lean to the left
    private Node rotateLeft(Node h) { //见图3.3.16
        // assert (h != null) && isRed(h.right);
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = x.left.color;
        x.left.color = RED;
        x.size = h.size;
        h.size = size(h.left) + size(h.right) + 1;
        return x;
    }

    // flip the colors of a node and its two children使结点及其子树的颜色翻转
    private void flipColors(Node h) { //见图3.3.21
        // h must have opposite color of its two children
        // assert (h != null) && (h.left != null) && (h.right != null);
        // assert (!isRed(h) &&  isRed(h.left) &&  isRed(h.right))
        //    || (isRed(h)  && !isRed(h.left) && !isRed(h.right));
        h.color = !h.color;
        h.left.color = !h.left.color;
        h.right.color = !h.right.color;
    }
    
   /***************************************************************************
    *  Red-black tree deletion.
    ***************************************************************************/

    // Removes the smallest key and associated value from the symbol table.
    public void deleteMin() {
        if (isEmpty()) throw new NoSuchElementException("BST underflow");

        //先对根节点进行处理,没太理解意义何在
        // if both children of root are black, set root to red
        if (!isRed(root.left) && !isRed(root.right)) 
            root.color = RED;

        root = deleteMin(root);
        if (!isEmpty()) root.color = BLACK;
        // assert check();
    }

       




    // delete the key-value pair with the minimum key rooted at h
    private Node deleteMin(Node h) { 
        //因为是删除最小的结点，所以整体的方向肯定是往 左 找到一个处于树底层的节点
        if (h.left == null)
            return null;
        
        //删除操作中，为了避免删除2-节点之后形成的空节点。
        //在向下的操作中，要把把所有2-节点的节点全部上提，变成3-或4-节点的一部分。
        //并将该操作递归下去，上提沿途所有的2-结点
    	
    	//左侧连续两个黑色结点,意味着左子结点是2-节点
    	//（因为程序默认是“左倾的红黑树”，即如果有红色节点，一定是出现在左子树上）
        if (!isRed(h.left) && !isRed(h.left.left))
            h = moveRedLeft(h);
            //按这个逻辑来说，这个方法，应该实现了把h的左子节点变成“ 非2-节点 ”的功能

        h.left = deleteMin(h.left);
        return balance(h);
    }


    //Removes the largest key and associated value from the symbol table.
    public void deleteMax() {
        if (isEmpty()) throw new NoSuchElementException("BST underflow");

        // if both children of root are black, set root to red
        if (!isRed(root.left) && !isRed(root.right))
            root.color = RED;

        root = deleteMax(root);
        if (!isEmpty()) root.color = BLACK;
        // assert check();
    }

    // delete the key-value pair with the maximum key rooted at h
    private Node deleteMax(Node h) { 
        if (isRed(h.left))
            h = rotateRight(h);

        if (h.right == null)
            return null;

        if (!isRed(h.right) && !isRed(h.right.left))
            h = moveRedRight(h);

        h.right = deleteMax(h.right);

        return balance(h);
    }

    // Removes the specified key and its associated value from this symbol table     
    public void delete(Key key) { 
        if (key == null) throw new NullPointerException("argument to delete() is null");
        if (!contains(key)) return;

        // if both children of root are black, set root to red
        if (!isRed(root.left) && !isRed(root.right))
            root.color = RED;

        root = delete(root, key);
        if (!isEmpty()) root.color = BLACK;
        // assert check();
    }

    // delete the key-value pair with the given key rooted at h
    private Node delete(Node h, Key key) { 
        // assert get(h, key) != null;

        if (key.compareTo(h.key) < 0)  {
            if (!isRed(h.left) && !isRed(h.left.left))
                h = moveRedLeft(h);
            h.left = delete(h.left, key);
        }
        else {
            if (isRed(h.left))
                h = rotateRight(h);
            if (key.compareTo(h.key) == 0 && (h.right == null))
                return null;
            if (!isRed(h.right) && !isRed(h.right.left))
                h = moveRedRight(h);
            if (key.compareTo(h.key) == 0) {
                Node x = min(h.right);
                h.key = x.key;
                h.val = x.val;
                // h.val = get(h.right, min(h.right).key);
                // h.key = min(h.right).key;
                h.right = deleteMin(h.right);
            }
            else h.right = delete(h.right, key);
        }
        return balance(h);
    }

   //h红，左黑，左左黑； make h.left or one of its children red.
   //适用的情况是，目标节点是红色的，且其左侧连续两个黑色子节点(左子树存在2-结点)
    private Node moveRedLeft(Node h) {
        // assert (h != null);
        // assert isRed(h) && !isRed(h.left) && !isRed(h.left.left);
        //h红，左黑，左左黑

        flipColors(h);//对h的三条线，全部反转颜色
        
        //如果右子树是普通的2-节点，将形成以h为中心的4-节点。
        //满足h左子树为非2-节点的要求，对应284页图3.3.26中非if的情况
        if (isRed(h.right.left)) { //判定成功的条件，意味着右子树的节点 并不是 2-节点，对应284页图3.3.26中if的情况
            h.right = rotateRight(h.right);
            h = rotateLeft(h);
            flipColors(h);
        }
        return h;
    }

    // h红，右黑，右左黑；make h.right or one of its children red.
    private Node moveRedRight(Node h) {
        // assert (h != null);
        // assert isRed(h) && !isRed(h.right) && !isRed(h.right.left);
        flipColors(h);
        if (isRed(h.left.left)) { 
            h = rotateRight(h);
            flipColors(h);
        }
        return h;
    }
    
    //整理红黑树结构的函数，和插入代码最后的翻转操作一致
    // restore red-black tree invariant
    private Node balance(Node h) {
        // assert (h != null);

        if (isRed(h.right))                      h = rotateLeft(h);
        if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
        if (isRed(h.left) && isRed(h.right))     flipColors(h);

        h.size = size(h.left) + size(h.right) + 1;
        return h;
    }

   /***************************************************************************
    *  Utility functions.
    ***************************************************************************/

    /**
     * Returns the height of the BST (for debugging).
     * @return the height of the BST (a 1-node tree has height 0)
     */
    public int height() {
        return height(root);
    }
    private int height(Node x) {
        if (x == null) return -1;
        return 1 + Math.max(height(x.left), height(x.right));
    }

   /***************************************************************************
    *  Ordered symbol table methods.
    ***************************************************************************/

    /**
     * Returns the smallest key in the symbol table.
     * @return the smallest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("called min() with empty symbol table");
        return min(root).key;
    } 

    // the smallest key in subtree rooted at x; null if no such key
    private Node min(Node x) { 
        // assert x != null;
        if (x.left == null) return x; 
        else                return min(x.left); 
    } 

    /**
     * Returns the largest key in the symbol table.
     * @return the largest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("called max() with empty symbol table");
        return max(root).key;
    } 

    // the largest key in the subtree rooted at x; null if no such key
    private Node max(Node x) { 
        // assert x != null;
        if (x.right == null) return x; 
        else                 return max(x.right); 
    } 


    //Returns the largest key in the symbol table less than or equal to {@code key}.
    public Key floor(Key key) {
        if (key == null) throw new NullPointerException("argument to floor() is null");
        if (isEmpty()) throw new NoSuchElementException("called floor() with empty symbol table");
        Node x = floor(root, key);
        if (x == null) return null;
        else           return x.key;
    }    

    // the largest key in the subtree rooted at x less than or equal to the given key
    private Node floor(Node x, Key key) {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp == 0) return x;
        if (cmp < 0)  return floor(x.left, key);
        Node t = floor(x.right, key);
        if (t != null) return t; 
        else           return x;
    }

    //Returns the smallest key in the symbol table greater than or equal to {@code key}.
    public Key ceiling(Key key) {
        if (key == null) throw new NullPointerException("argument to ceiling() is null");
        if (isEmpty()) throw new NoSuchElementException("called ceiling() with empty symbol table");
        Node x = ceiling(root, key);
        if (x == null) return null;
        else           return x.key;  
    }

    // the smallest key in the subtree rooted at x greater than or equal to the given key
    private Node ceiling(Node x, Key key) {  
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp == 0) return x;
        if (cmp > 0)  return ceiling(x.right, key);
        Node t = ceiling(x.left, key);
        if (t != null) return t; 
        else           return x;
    }

    // Return the kth smallest key in the symbol table.
    public Key select(int k) {
        if (k < 0 || k >= size()) throw new IllegalArgumentException();
        Node x = select(root, k);
        return x.key;
    }

    // the key of rank k in the subtree rooted at x
    private Node select(Node x, int k) {
        // assert x != null;
        // assert k >= 0 && k < size(x);
        int t = size(x.left); 
        if      (t > k) return select(x.left,  k); 
        else if (t < k) return select(x.right, k-t-1); 
        else            return x; 
    } 

    //Return the number of keys in the symbol table strictly less than {@code key}.
    public int rank(Key key) {
        if (key == null) throw new NullPointerException("argument to rank() is null");
        return rank(key, root);
    } 

    // number of keys less than key in the subtree rooted at x
    private int rank(Key key, Node x) { //和二叉树的rank一样的
        if (x == null) return 0; 
        int cmp = key.compareTo(x.key); 
        if      (cmp < 0) return rank(key, x.left); 
        else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right); 
        else              return size(x.left); 
    } 

   /***************************************************************************
    *  Range count and range search.
    ***************************************************************************/

    // Returns all keys in the symbol table as an {@code Iterable}.
    public Iterable<Key> keys() {
        if (isEmpty()) return new Queue<Key>();
        return keys(min(), max());
    }

    //Returns all keys in the symbol table in the given range, as an {@code Iterable}.
    public Iterable<Key> keys(Key lo, Key hi) {
        if (lo == null) throw new NullPointerException("first argument to keys() is null");
        if (hi == null) throw new NullPointerException("second argument to keys() is null");

        Queue<Key> queue = new Queue<Key>();
        // if (isEmpty() || lo.compareTo(hi) > 0) return queue;
        keys(root, queue, lo, hi);
        return queue;
    } 

    // add the keys between lo and hi in the subtree rooted at x
    // to the queue
    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) { 
        if (x == null) return; 
        int cmplo = lo.compareTo(x.key); 
        int cmphi = hi.compareTo(x.key); 
        if (cmplo < 0) keys(x.left, queue, lo, hi); 
        if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key); 
        if (cmphi > 0) keys(x.right, queue, lo, hi); 
    } 

    //Returns the number of keys in the symbol table in the given range.
    public int size(Key lo, Key hi) {
        if (lo == null) throw new NullPointerException("first argument to size() is null");
        if (hi == null) throw new NullPointerException("second argument to size() is null");

        if (lo.compareTo(hi) > 0) return 0;
        if (contains(hi)) return rank(hi) - rank(lo) + 1;
        else              return rank(hi) - rank(lo);
    }


   /***************************************************************************
    *  Check integrity of red-black tree data structure.
    ***************************************************************************/
    private boolean check() {
        if (!isBST())            StdOut.println("Not in symmetric order");
        if (!isSizeConsistent()) StdOut.println("Subtree counts not consistent");
        if (!isRankConsistent()) StdOut.println("Ranks not consistent");
        if (!is23())             StdOut.println("Not a 2-3 tree");
        if (!isBalanced())       StdOut.println("Not balanced");
        return isBST() && isSizeConsistent() && isRankConsistent() && is23() && isBalanced();
    }

    // does this binary tree satisfy symmetric order?
    // Note: this test also ensures that data structure is a binary tree since order is strict
    private boolean isBST() {
        return isBST(root, null, null);
    }

    // is the tree rooted at x a BST with all keys strictly between min and max
    // (if min or max is null, treat as empty constraint)
    // Credit: Bob Dondero's elegant solution
    private boolean isBST(Node x, Key min, Key max) {
        if (x == null) return true;
        if (min != null && x.key.compareTo(min) <= 0) return false;
        if (max != null && x.key.compareTo(max) >= 0) return false;
        return isBST(x.left, min, x.key) && isBST(x.right, x.key, max);
    } 

    // are the size fields correct?
    private boolean isSizeConsistent() { return isSizeConsistent(root); }
    private boolean isSizeConsistent(Node x) {
        if (x == null) return true;
        if (x.size != size(x.left) + size(x.right) + 1) return false;
        return isSizeConsistent(x.left) && isSizeConsistent(x.right);
    } 

    // check that ranks are consistent
    private boolean isRankConsistent() {
        for (int i = 0; i < size(); i++)
            if (i != rank(select(i))) return false;
        for (Key key : keys())
            if (key.compareTo(select(rank(key))) != 0) return false;
        return true;
    }

    // Does the tree have no red right links, and at most one (left)
    // red links in a row on any path?
    private boolean is23() { return is23(root); }
    private boolean is23(Node x) {
        if (x == null) return true;
        if (isRed(x.right)) return false;
        if (x != root && isRed(x) && isRed(x.left))
            return false;
        return is23(x.left) && is23(x.right);
    } 

    // do all paths from root to leaf have same number of black edges?
    private boolean isBalanced() { 
        int black = 0;     // number of black links on path from root to min
        Node x = root;
        while (x != null) {
            if (!isRed(x)) black++;
            x = x.left;
        }
        return isBalanced(root, black);
    }

    // does every path from the root to a leaf have the given number of black links?
    private boolean isBalanced(Node x, int black) {
        if (x == null) return black == 0;
        if (!isRed(x)) black--;
        return isBalanced(x.left, black) && isBalanced(x.right, black);
    } 


    //Unit tests the {@code RedBlackBST} data type.
    public static void main(String[] args) { 
        RedBlackBST<String, Integer> st = new RedBlackBST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }
        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
        StdOut.println();
    }
}
```
归并排序、二分查找：信奉绝对的**中点**
快速排序、二叉查找树：信奉一个相对的“**分割点**”，使得分割点左侧都比它小，分割点右侧都比它大

二叉树可以快速查找，实现起来也不算特别困难，只是最坏情况下的劣势比较明显；2-3树组织形式d更加灵活，局部变形消化波动的能力简直完美，但是为此结点的设计是一个大难题。**红黑树** 简单的说来就是，**用二叉树表示的2-3树**。这样一来，就可以在逻辑上实现2-3树的结构，但是同时又在代码上沿用了二叉树的基础。

# 3.4 散列表
散列表的使用分为两步：第一步，用**散列函数**将被查找的键转化为数组的索引；第二步，处理碰撞冲突。
1、使用相同的散列函数，直接为每一个元素分配数组中的一个位置，无疑是搜索速度最快的选择，但是若不限制数组的大小，会造成很多浪费（毕竟散列函数的目的是均匀分布）。
2、不使用额外的辅助容器，直接在原数据中进行顺序查找，显然是很节省空间的，但是时间上又太过缓慢。
3、综合1与2的优劣，我们希望散列表能够在速度和空间上，给出一种折衷的方案。即可以理解为，在保证速度的前提下，尽可能的减少不必要的空间分配。

## 拉链法
规定一个大小有限的数组。对于容量远小于样本的数组，在散列时难免会发生冲突。不要紧，数组的每一个元素都是一个链表，这样一来，散列到同一位置的值，可以存储在链表中。搜索时，首先根据散列值寻找到特定链表，然后再在链表中顺序搜索。
```
public class SeparateChainingHashST<Key, Value> {
    private static final int INIT_CAPACITY = 4;

    private int n;                                // 键值对总数
    private int m;                                // 散列表的大小
    private SequentialSearchST<Key, Value>[] st;  // 链表符号表的数组

    public SeparateChainingHashST() {this(INIT_CAPACITY);} 

    public SeparateChainingHashST(int m) {
        this.m = m;
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[m];
        for (int i = 0; i < m; i++) //数组中的每一个元素，都是一个链表
            st[i] = new SequentialSearchST<Key, Value>();
    } 

    // resize the hash table to have the given number of chains,
    // rehashing all of the keys
    private void resize(int chains) {
        SeparateChainingHashST<Key, Value> temp = new SeparateChainingHashST<Key, Value>(chains);
        for (int i = 0; i < m; i++) {
            for (Key key : st[i].keys()) {
                temp.put(key, st[i].get(key));//这里不是拷贝，而是重新散列
            }
        }
        this.m  = temp.m;
        this.n  = temp.n;
        this.st = temp.st;
    }

    // hash value between 0 and m-1
    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % m; 
        //java对象的hashcode可能是负数，而0x7fffffff表示32位带符号最大整数
        //这里这样处理可以确保被除数是一个正整数
    } 

    public int size() {return n;} 

    public boolean isEmpty() {return size() == 0;}

    // Returns true if this symbol table contains the specified key.
    public boolean contains(Key key) {
        if (key == null) throw new NullPointerException("argument to contains() is null");
        return get(key) != null;
    } 

    // Returns the value associated with the specified key in this symbol table.
    public Value get(Key key) {
        if (key == null) throw new NullPointerException("argument to get() is null");
        int i = hash(key); //每个i对应着数组的一个位置，st[i]所指代的实际上是该位置上的链表
        return st[i].get(key);
    } 

    // 覆盖，新增
    public void put(Key key, Value val) {
        if (key == null) throw new NullPointerException("first argument to put() is null");
        if (val == null) {
            delete(key);
            return;
        }

        // double table size if average length of list >= 10
        if (n >= 10*m) resize(2*m);

        int i = hash(key);
        if (!st[i].contains(key)) n++;
        st[i].put(key, val);//这个put是链表存储的put（找到目标就覆盖，否则新增）
    } 

    // Removes the specified key and its associated value from this symbol table     
    public void delete(Key key) {
        if (key == null) throw new NullPointerException("argument to delete() is null");

        int i = hash(key);
        if (st[i].contains(key)) n--;
        st[i].delete(key);//依然是链表对象，执行链表的delete

        // halve table size if average length of list <= 2
        if (m > INIT_CAPACITY && n <= 2*m) resize(m/2);
    } 

    // return keys in symbol table as an Iterable
    public Iterable<Key> keys() {
        Queue<Key> queue = new Queue<Key>();
        for (int i = 0; i < m; i++) {
            for (Key key : st[i].keys())
                queue.enqueue(key);
        }
        return queue;
    } 


    // Unit tests the {@code SeparateChainingHashST} data type.
    public static void main(String[] args) { 
        SeparateChainingHashST<String, Integer> st = new SeparateChainingHashST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        // print keys
        for (String s : st.keys()) 
            StdOut.println(s + " " + st.get(s)); 

    }

}
```
## 线性探测法
建立一个比较大的数组，将所有的数据值散列进去。但是冲突依然会存在，线性探测法的思路是：如果散列值位置发生冲突，就检查下一个位置是否可用，直到检测到空位子，再写进去。搜索的时候，也是一样的思路，先找到散列值的位置，然后依次向后检索判断。
有一个问题，首先散列表应该是足够大的（至少要大于数据量），其次在散列时，如果 **键簇** 过长，显然会影响搜索的效率。数学推导给出命题，**数组使用率小于1/2的时候，探测次数的期望在1.5次到2.5次之间**，这还是很经济的。
```
public class LinearProbingHashST<Key, Value> {
    private static final int INIT_CAPACITY = 4;

    private int n;           // 符号表中键值对数量
    private int m;           // 线性探测表长度
    private Key[] keys;      // the keys
    private Value[] vals;    // the values

    public LinearProbingHashST() {
        this(INIT_CAPACITY);
    }

    public LinearProbingHashST(int capacity) {
        m = capacity;
        n = 0;
        keys = (Key[])   new Object[m];
        vals = (Value[]) new Object[m];
    }

    public int size() {return n;}

    public boolean isEmpty() { return size() == 0;}

    // Returns true if this symbol table contains the specified key.
    public boolean contains(Key key) {
        if (key == null) throw new NullPointerException("argument to contains() is null");
        return get(key) != null;
    }

    // hash function for keys - returns value between 0 and M-1
    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % m;
    }

    // resizes the hash table to the given capacity by re-hashing all of the keys
    private void resize(int capacity) {
        LinearProbingHashST<Key, Value> temp = new LinearProbingHashST<Key, Value>(capacity);
        for (int i = 0; i < m; i++) {
            if (keys[i] != null) {
                temp.put(keys[i], vals[i]);
            }
        }
        keys = temp.keys;
        vals = temp.vals;
        m    = temp.m;
    }

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {@code null}.
     *
     * @param  key the key
     * @param  val the value
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public void put(Key key, Value val) {
        if (key == null) throw new NullPointerException("first argument to put() is null");

        if (val == null) {
            delete(key);
            return;
        }

        // double table size if 50% full
        if (n >= m/2) resize(2*m);

        int i;
        for (i = hash(key); keys[i] != null; i = (i + 1) % m) { // “i=(i+1)%m” 使得计数可以循环
            if (keys[i].equals(key)) {
                vals[i] = val;
                return;
            }
        }
        keys[i] = key;
        vals[i] = val;
        n++;
    }

    // Returns the value associated with the specified key.
    public Value get(Key key) {
        if (key == null) throw new NullPointerException("argument to get() is null");
        for (int i = hash(key); keys[i] != null; i = (i + 1) % m)
            if (keys[i].equals(key))
                return vals[i];
        return null;
    }

    // Removes the specified key and its associated value from this symbol table     
    public void delete(Key key) {
        if (key == null) throw new NullPointerException("argument to delete() is null");
        if (!contains(key)) return;

        // find position i of key
        int i = hash(key);
        while (!key.equals(keys[i])) {
            i = (i + 1) % m;
        }

        // delete key and associated value
        keys[i] = null;
        vals[i] = null;

        // rehash all keys in same cluster，同键簇其他键也要重新散列
        i = (i + 1) % m;
        while (keys[i] != null) {
            // delete keys[i] an vals[i] and reinsert
            Key   keyToRehash = keys[i];
            Value valToRehash = vals[i];
            keys[i] = null;
            vals[i] = null;
            n--; 
            //put里会使得n++，所以这里用n--中和一下。
            //按道理也解释得通，因为刚置空，键值对总数确实是少了一个，只不过后面的put还会把这一个加回来
            put(keyToRehash, valToRehash);
            i = (i + 1) % m;
        }

        n--; //在删除目标键值对、重新散列其他同簇键值对之后；这个n--才是真正的修改散列表键值对数目的代码

        // halves size of array if it's 12.5% full or less
        if (n > 0 && n <= m/8) resize(m/2);

        assert check();
    }

    /**
     * Returns all keys in this symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     *
     * @return all keys in this symbol table
     */
    public Iterable<Key> keys() {
        Queue<Key> queue = new Queue<Key>();
        for (int i = 0; i < m; i++)
            if (keys[i] != null) queue.enqueue(keys[i]);
        return queue;
    }

    // integrity check - don't check after each put() because
    // integrity not maintained during a delete()
    private boolean check() {

        // check that hash table is at most 50% full
        if (m < 2*n) {
            System.err.println("Hash table size m = " + m + "; array size n = " + n);
            return false;
        }

        // check that each key in table can be found by get()
        for (int i = 0; i < m; i++) {
            if (keys[i] == null) continue;
            else if (get(keys[i]) != vals[i]) {
                System.err.println("get[" + keys[i] + "] = " + get(keys[i]) + "; vals[i] = " + vals[i]);
                return false;
            }
        }
        return true;
    }

    // Unit tests the {@code LinearProbingHashST} data type.
    public static void main(String[] args) { 
        LinearProbingHashST<String, Integer> st = new LinearProbingHashST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        // print keys
        for (String s : st.keys()) 
            StdOut.println(s + " " + st.get(s)); 
    }
}
```
# 3.5 应用
散列表的优点在于代码相对简单，查找时间最优；但是散列之后的数据是无序的。
二叉查找树的优点在于逻辑结构更简单，而且因为有序，所以支持基于数据顺序的相关操作。